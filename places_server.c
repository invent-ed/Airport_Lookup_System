/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <ctype.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "places.h"
#include "airports.h"
#include "./trie/trie.h"

#define K 5
#define NEW_STRUCT(s) (s *)malloc(sizeof(s))
#define NEW_STRING(s) (char *)malloc(strlen(s)+1)
#define CPY_STRING(dst, src) dst = NEW_STRING(src); strcpy(dst, src)
#define SUBSTR(src, dst, start, end) memcpy(dst, &src[start-1], end-start+1); dst[end-start+1] = '\0'

#define NUM_ENTRIES (25375)

// function declarations for processing RPC call
airportsRet * findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate);
CLIENT * connectToClient(char *host);
void checkIfResultIsNull(airportsRet *result, CLIENT *clnt);
void disconnectFromClient(CLIENT *clnt, airportsRet *result);

void print_paths(const struct trie_node *const node, int pos) {
  static char prefix[256];
  char c = node->letter;
  if (node->down != NULL) {
    prefix[pos] = c;
    printf("%c", c);
    print_paths(node->down, pos + 1);
  }
  else {
    printf("%c\n", c);
  }
  if (node->next != NULL) {
    for (int i = 0; i < pos; i++) {
      printf("%c", prefix[i]);
    }
    print_paths(node->next, pos);
  }
}

void str_lower(char *str) {
    while (*str != '\0') {
        *str = tolower(*str);
        str++;
    }
}

void str_trim_end(char *str, int end, int (*check)(int), bool cond) {
    int i = end;
    while (check(str[i]) == cond) {
        str[i--] = '\0';
    }
}

void read_file(struct location *locs, struct trie *trie) {
    char *placesFile = "data/places2k.txt";
    FILE *fp = fopen(placesFile, "r");
    if (fp == NULL) {
        printf("Could not open file %s\n", placesFile);
        exit(1);
    }
    char line[256], state[3], city[65], latitude[11], longitude[12];
    int i = 0;
    while (fgets(line, sizeof(line), fp) != NULL) {
        SUBSTR(line, state, 1, 2);
        SUBSTR(line, city, 10, 73);
        SUBSTR(line, latitude, 144, 153);
        SUBSTR(line, longitude, 154, 164);
        str_trim_end(state, sizeof(state) - 1, isalpha, false);
        str_trim_end(city, sizeof(city) - 1, isalpha, false);
        str_trim_end(latitude, sizeof(latitude) - 1, isdigit, false);
        str_trim_end(longitude, sizeof(longitude) - 1, isdigit, false);
        str_lower(state);
        str_lower(city);
        locs[i] = (struct location) {
            .latitude = atof(latitude),
            .longitude = atof(longitude),
        };
        for (int j = 0; j < 4; j++) {
            locs[i].state[j] = state[j];
        }
        for (int j = 0; j < 50; j++) {
            locs[i].city[j] = city[j];
        }
        int stateLen = strlen(state);
        int cityLen = strlen(city);
        int size = stateLen + cityLen;
        char *key = malloc(size + 1);
        for (int i = 0; i < stateLen; i++) {
            key[i] = state[i];
        }
        for (int i = stateLen; i < size; i++) {
            key[i] = city[i - stateLen];
        }
        key[size] = '\0';
        trie_add_entry(trie, key, locs + i);
        free(key);

        i++;
    }
    fclose(fp);
}

// places server main function
placesRet *
airports_near_city_1_svc(clientArg *argp, struct svc_req *rqstp)
{
    static struct location locs[NUM_ENTRIES];
    static struct trie trie;
	static placesRet result;

    (void)rqstp; // removes compilation warning
    // initialize server function
    xdr_free((xdrproc_t)xdr_placesRet, &result);
    result.err = 0;
    
    // populate trie if it dne
    if (trie.root == NULL) {
        read_file(locs, &trie);
    }
    
    // build key
    int stateLen = strlen(argp->state);
    int cityLen = strlen(argp->city);
    int size = stateLen + cityLen;
    char *key = malloc(size + 1);
    for (int i = 0; i < stateLen; i++) {
        key[i] = argp->state[i];
    }
    for (int i = stateLen; i < size; i++) {
        key[i] = argp->city[i - stateLen];
    }
    key[size] = '\0';
    str_lower(key);

    // query trie
    struct trie_search_result search = trie_search(&trie, key);
    free(key);
    struct location *query = search.last->data;

    // bad query
    if (search.last == NULL) {
        result.err = 4;
        return &result;
    }
    printf("%c %c\n", search.last->letter, *(search.rest));
    if (search.last->letter != *(search.rest)) {
        result.err = 4;
        return &result;
    }

    // match the closest prefix
    while (query == NULL && search.last->down != NULL) {
        search.last = search.last->down;
        if (search.last->next != NULL) break;
    }

    // get query data if unambiguous
    if (search.last->down == NULL && search.last->next == NULL) {   // unambiguous prefix
        query = search.last->data;
    } else {   // ambiguous prefix
        result.err = 3;
        return &result;
    }

    // query airports server
    placesArg *coordinate = NEW_STRUCT(placesArg);
    coordinate->latitude = query->latitude;
    coordinate->longitude = query->longitude;
	CLIENT *clnt = connectToClient("localhost");
    airportsRet *airportsResult = findAirportsNearCoord(clnt, coordinate);

    // return results
    result.placesRet_u.results.location = *query;
    struct airport *airport_in = airportsResult->airportsRet_u.result.airports;
    struct airportInfo *airport_out = result.placesRet_u.results.airports;
    for (int i = 0; i < 5; i++) {
        *(airport_out + i) = *(airportInfo *)(airport_in + i);
    }

    disconnectFromClient(clnt, airportsResult);
	return &result;
}

airportsRet *
findAirportsNearCoord(CLIENT *clnt, placesArg *coordinate)
{
	airportsRet *result = airports_near_coord_1(coordinate, clnt);
    checkIfResultIsNull(result, clnt);
    return result;
}

CLIENT *
connectToClient(char *host) 
{
    #ifndef	DEBUG
	CLIENT *clnt = clnt_create(host, AIRPORTS_PROG, AIRPORTS_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}
    #endif	/* DEBUG */
}

void
checkIfResultIsNull(airportsRet *result, CLIENT *clnt) 
{
	if (result == (airportsRet *) NULL) {
		clnt_perror(clnt, "call failed");
	}
}

void
disconnectFromClient(CLIENT *clnt, airportsRet *result) 
{
    #ifndef	DEBUG
    clnt_freeres(clnt, (xdrproc_t)xdr_airportsRet, (void *)result);
	clnt_destroy(clnt);
    #endif	 /* DEBUG */
}
